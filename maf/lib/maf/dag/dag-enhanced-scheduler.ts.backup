// ABOUTME: Enhanced scheduler with DAG dependency validation integration
// ABOUTME: Extends base scheduler with dependency-aware task reservation and execution

import { Scheduler } from '../core/scheduler';
import { DAGDependencyManager, DAGTask, DAGValidationResult, TaskDependency } from './dag-dependency-manager';
import { DAGSchema, TaskDependencyRow } from './dag-schema';

export interface DependencyAwareTask {
  id: string;
  title?: string;
  description?: string;
  constraint?: string;
  priority: number;
  dependencies: TaskDependency[];
  files?: string[];
  metadata?: Record<string, any>;
}

export interface EnhancedReservationResult {
  task: any;
  attempt: number;
  lease_expires_at: number;
  dependencyValidation: DAGValidationResult;
  canExecute: boolean;
  blockedBy: string[];
  dependentTasks: string[];
}

/**
 * Enhanced scheduler with DAG dependency validation
 */
export class DAGEnhancedScheduler {
  private baseScheduler: Scheduler;
  private dagManager: DAGDependencyManager;
  private db: any;

  constructor(db: any) {
    this.db = db;
    this.baseScheduler = new Scheduler(db);
    this.dagManager = new DAGDependencyManager();

    // Initialize database schema if needed
    DAGSchema.initializeTables(db);

    // Load existing tasks and dependencies from database
    this.loadTasksAndDependenciesFromDatabase();
  }

  /**
   * Reserve a task with dependency validation
   */
  reserveWithDependencies(agentId: string, ttlMs = 30_000): null | EnhancedReservationResult {
    // First, validate the dependency graph
    const validation = this.dagManager.validateGraph();

    if (!validation.isValid) {
      console.error('Dependency graph validation failed:', validation.errors);
      // Still allow reservation for tasks not involved in cycles
    }

    // Get executable tasks from database (since tasks are added via SQL)
    const executableTasks = this.getExecutableTasksFromDatabase();

    if (executableTasks.length === 0) {
      // No tasks are executable due to dependencies
      return null;
    }

    // Try to reserve executable tasks using base scheduler
    for (const task of executableTasks) {
      // Try to reserve this specific task
      const reservation = this.tryReserveSpecificTask(task.id, agentId, ttlMs);
      if (reservation) {
        const dependents = this.getTaskDependents(task.id);
        const blockedBy = this.getTaskBlockers(task.id);

        return {
          ...reservation,
          dependencyValidation: validation,
          canExecute: true,
          blockedBy,
          dependentTasks: dependents
        };
      }
    }

    // Fallback to regular reservation if no specific task reservation works
    const fallbackReservation = this.baseScheduler.reserve(agentId, ttlMs);
    if (fallbackReservation) {
      const dependents = this.getTaskDependents(fallbackReservation.task.id);
      const blockedBy = this.getTaskBlockers(fallbackReservation.task.id);

      return {
        ...fallbackReservation,
        dependencyValidation: validation,
        canExecute: blockedBy.length === 0,
        blockedBy,
        dependentTasks: dependents
      };
    }

    return null;
  }

  /**
   * Add a task with dependencies to the system
   */
  addTaskWithDependencies(task: DependencyAwareTask): boolean {
    try {
      // Add task to database first
      const now = Date.now();
      this.db.prepare(`
        INSERT OR REPLACE INTO tasks (
          id, title, description, "constraint", "priority", "state",
          created_at, updated_at, files
        ) VALUES (?, ?, ?, ?, ?, 'READY', ?, ?, ?)
      `).run(
        task.id,
        task.title,
        task.description || null,
        task.constraint || null,
        task.priority,
        now,
        now,
        task.files ? JSON.stringify(task.files) : null
      );

      // Add to DAG manager
      const dagTask: DAGTask = {
        id: task.id,
        title: task.title,
        description: task.description,
        constraint: task.constraint,
        priority: task.priority,
        dependencies: task.dependencies,
        metadata: task.metadata
      };

      this.dagManager.addTask(dagTask);

      // Add dependencies to database
      for (const dep of task.dependencies) {
        DAGSchema.insertDependency(this.db, {
          task_id: dep.taskId,
          depends_on_task_id: dep.dependsOn,
          dependency_type: dep.dependencyType,
          description: dep.description,
          metadata: dep.description ? { description: dep.description } : undefined
        });
      }

      return true;
    } catch (error) {
      console.error('Failed to add task with dependencies:', error);
      return false;
    }
  }

  /**
   * Add a dependency between existing tasks
   */
  addDependency(taskId: string, dependsOn: string, type: 'hard' | 'soft' = 'hard', description?: string): boolean {
    try {
      // Ensure both tasks exist in database before creating dependency
      const taskExists = this.db.prepare(`SELECT COUNT(*) as count FROM tasks WHERE id = ?`).get(taskId);
      const depExists = this.db.prepare(`SELECT COUNT(*) as count FROM tasks WHERE id = ?`).get(dependsOn);

      if (!taskExists || taskExists.count === 0) {
        throw new Error(`Task ${taskId} does not exist in database`);
      }
      if (!depExists || depExists.count === 0) {
        throw new Error(`Task ${dependsOn} does not exist in database`);
      }

      // Reload tasks from database to ensure we have the latest state
      this.reloadTasksFromDatabase();

      // Check if this would create a cycle
      if (this.dagManager.wouldCreateCycle(taskId, dependsOn)) {
        throw new Error(`Adding dependency ${taskId} -> ${dependsOn} would create a cycle`);
      }

      // Add to DAG manager
      this.dagManager.addDependency(taskId, dependsOn, type);

      // Add to database
      DAGSchema.insertDependency(this.db, {
        task_id: taskId,
        depends_on_task_id: dependsOn,
        dependency_type: type,
        description
      });

      return true;
    } catch (error) {
      console.error('Failed to add dependency:', error);
      // Re-throw the error instead of returning false so tests can catch it
      throw error;
    }
  }

  /**
   * Remove a dependency between tasks
   */
  removeDependency(taskId: string, dependsOn: string): boolean {
    try {
      // Remove from DAG manager
      this.dagManager.removeDependency(taskId, dependsOn);

      // Remove from database
      DAGSchema.deleteDependency(this.db, taskId, dependsOn);

      return true;
    } catch (error) {
      console.error('Failed to remove dependency:', error);
      return false;
    }
  }

  /**
   * Get tasks in execution order (topologically sorted)
   */
  getTasksInExecutionOrder(constraint?: string): DependencyAwareTask[] {
    // Ensure DAG manager has latest tasks
    this.ensureDAGManagerSync();
    
    const dagTasks = this.dagManager.getTasksInDependencyOrder(constraint);

    return dagTasks.map(dagTask => ({
      id: dagTask.id,
      title: dagTask.title,
      description: dagTask.description,
      constraint: dagTask.constraint,
      priority: dagTask.priority,
      dependencies: dagTask.dependencies,
      metadata: dagTask.metadata
    }));
  }

  /**
   * Ensure DAG manager has all tasks from database
   */
  private ensureDAGManagerSync(): void {
    const dbTaskCount = this.db.prepare('SELECT COUNT(*) as count FROM tasks').get();
    const dagTaskCount = this.dagManager['graph'].nodes.size;
    
    if (dbTaskCount.count !== dagTaskCount) {
      console.log(`Syncing DAG manager: database has ${dbTaskCount.count} tasks, DAG manager has ${dagTaskCount}`);
      this.reloadTasksFromDatabase();
    }
  }

  /**
   * Get tasks that are ready for execution
   */
  getReadyTasks(constraint?: string): DependencyAwareTask[] {
    // Ensure DAG manager has latest tasks
    this.ensureDAGManagerSync();
    
    const executableTasks = this.dagManager.getExecutableTasks();

    if (constraint) {
      return executableTasks
        .filter(task => !task.constraint || task.constraint === constraint)
        .map(dagTask => ({
          id: dagTask.id,
          title: dagTask.title,
          description: dagTask.description,
          constraint: dagTask.constraint,
          priority: dagTask.priority,
          dependencies: dagTask.dependencies,
          metadata: dagTask.metadata
        }));
    }

    return executableTasks.map(dagTask => ({
      id: dagTask.id,
      title: dagTask.title,
      description: dagTask.description,
      constraint: dagTask.constraint,
      priority: dagTask.priority,
      dependencies: dagTask.dependencies,
      metadata: dagTask.metadata
    }));
  }

  /**
   * Get tasks that are blocked by dependencies
   */
  getBlockedTasks(constraint?: string): DependencyAwareTask[] {
    const validation = this.dagManager.validateGraph();
    const allTasks = Array.from(this.dagManager['graph'].nodes.values());

    const blockedTasks: DependencyAwareTask[] = [];

    for (const dagTask of allTasks) {
      if (constraint && dagTask.constraint !== constraint) {
        continue;
      }

      const hasUnmetDependencies = dagTask.dependencies.some(dep => {
        const depTask = this.dagManager['graph'].nodes.get(dep.dependsOn);
        return depTask && !this.isTaskCompleted(dep.dependsOn);
      });

      if (hasUnmetDependencies) {
        blockedTasks.push({
          id: dagTask.id,
          title: dagTask.title,
          description: dagTask.description,
          constraint: dagTask.constraint,
          priority: dagTask.priority,
          dependencies: dagTask.dependencies,
          metadata: dagTask.metadata
        });
      }
    }

    return blockedTasks.sort((a, b) => a.priority - b.priority);
  }

  /**
   * Get comprehensive dependency status for monitoring
   */
  getDependencyStatus(): {
    validation: DAGValidationResult;
    statistics: any;
    readyTasks: number;
    blockedTasks: number;
    totalTasks: number;
  } {
    const validation = this.dagManager.validateGraph();
    // Use database statistics for compatibility with tests
    const statistics = DAGSchema.getDependencyStatistics(this.db);
    const readyTasks = this.dagManager.getExecutableTasks().length;
    const blockedTasks = statistics.totalTasks - readyTasks;

    return {
      validation,
      statistics,
      readyTasks,
      blockedTasks,
      totalTasks: statistics.totalTasks
    };
  }

  /**
   * Validate the entire dependency graph
   */
  validateDependencies(): DAGValidationResult {
    return this.dagManager.validateGraph();
  }

  /**
   * Renew task lease (delegates to base scheduler)
   */
  renew(task_id: string, agent_id: string, ttlMs = 30_000): boolean {
    return this.baseScheduler.renew(task_id, agent_id, ttlMs);
  }

  /**
   * Start task execution (delegates to base scheduler)
   */
  start(task_id: string): void {
    this.baseScheduler.start(task_id);
  }

  /**
   * Mark task as verifying (delegates to base scheduler)
   */
  verifying(task_id: string): void {
    this.baseScheduler.verifying(task_id);
  }

  /**
   * Mark task as committed (delegates to base scheduler)
   */
  committed(task_id: string): void {
    this.baseScheduler.committed(task_id);
  }

  /**
   * Log task error (delegates to base scheduler)
   */
  error(task_id: string, err: Error, context?: Record<string, any>): void {
    this.baseScheduler.error(task_id, err, context);
  }

  /**
   * Enhanced pickNextTask with dependency awareness
   */
  async pickNextTask(agentId: string): Promise<{
    beadId: string;
    constraint?: string;
    files?: string[];
    assignedAgent?: string | null;
    title?: string;
    dependencies?: TaskDependency[];
    blockedBy?: string[];
  } | null> {
    const reservation = this.reserveWithDependencies(agentId);
    if (!reservation) {
      return null;
    }

    const task = reservation.task;
    return {
      beadId: task.id,
      constraint: task.constraint,
      files: task.files ? JSON.parse(task.files) : undefined,
      assignedAgent: agentId,
      title: task.title || task.description,
      dependencies: this.getTaskDependencies(task.id),
      blockedBy: reservation.blockedBy
    };
  }

  // Private helper methods

  private loadTasksAndDependenciesFromDatabase(): void {
    try {
      // First, load all tasks from database into DAG manager
      const tasks = this.db.prepare(`
        SELECT * FROM tasks
      `).all();

      for (const task of tasks) {
        this.dagManager.addTask({
          id: task.id,
          title: task.title,
          description: task.description,
          constraint: task.constraint,
          priority: task.priority,
          dependencies: [] // Will add dependencies next
        });
      }

      // Then, load all dependencies
      const dependencies = DAGSchema.getAllDependencies(this.db);

      for (const dep of dependencies) {
        try {
          this.dagManager.addDependency(dep.task_id, dep.depends_on_task_id, dep.dependency_type);
        } catch (error) {
          // Skip invalid dependencies during loading
          console.warn(`Skipping invalid dependency: ${dep.task_id} -> ${dep.depends_on_task_id}`);
        }
      }

      console.log(`Loaded ${tasks.length} tasks and ${dependencies.length} dependencies from database`);
    } catch (error) {
      console.error('Failed to load tasks and dependencies from database:', error);
    }
  }

  /**
   * Reload tasks from database (call this after adding tasks via SQL)
   */
  private reloadTasksFromDatabase(): void {
    // Clear existing tasks in DAG manager
    this.dagManager.clear();
    // Reload from database
    this.loadTasksAndDependenciesFromDatabase();
  }

  private ensureTaskInDAGManager(taskId: string): void {
    // Check if task already exists in DAG manager
    if (this.dagManager.hasTask(taskId)) {
      return;
    }

    // Load task from database if not in DAG manager
    const task = this.db.prepare(`SELECT * FROM tasks WHERE id = ?`).get(taskId);
    if (task) {
      this.dagManager.addTask({
        id: task.id,
        title: task.title,
        description: task.description,
        constraint: task.constraint,
        priority: task.priority,
        dependencies: []
      });
    }
  }

  private getExecutableTasksFromDatabase(): any[] {
    // Get all tasks that are READY and have no unmet dependencies
    const allTasks = this.db.prepare(`
      SELECT * FROM tasks WHERE "state" = 'READY'
    `).all();

    const executableTasks = [];

    for (const task of allTasks) {
      const dependencies = DAGSchema.getTaskDependencies(this.db, task.id);
      const hasUnmetDependencies = dependencies.some(dep => {
        const depTask = this.db.prepare(`SELECT "state" FROM tasks WHERE id = ?`).get(dep.depends_on_task_id);
        return !depTask || depTask.state !== 'COMMITTED';
      });

      if (!hasUnmetDependencies) {
        executableTasks.push(task);
      }
    }

    // Sort by priority, then by created_at
    return executableTasks.sort((a, b) => {
      if (a.priority !== b.priority) {
        return a.priority - b.priority;
      }
      return a.created_at - b.created_at;
    });
  }

  private tryReserveSpecificTask(taskId: string, agentId: string, ttlMs: number): any {
    // Try to reserve a specific task by checking if it exists and is READY
    const task = this.db.prepare(`
      SELECT * FROM tasks WHERE id = ? AND "state" = 'READY'
    `).get(taskId);

    if (!task) {
      return null;
    }

    // Check if task has unmet dependencies
    const dependencies = DAGSchema.getTaskDependencies(this.db, taskId);
    const hasUnmetDependencies = dependencies.some(dep => {
      const depTask = this.db.prepare(`SELECT "state" FROM tasks WHERE id = ?`).get(dep.depends_on_task_id);
      return !depTask || depTask.state !== 'COMMITTED';
    });

    if (hasUnmetDependencies) {
      return null;
    }

    // Use base scheduler to reserve
    const reservation = this.baseScheduler.reserve(agentId, ttlMs);

    // Check if we got the specific task we wanted
    if (reservation && reservation.task.id === taskId) {
      return reservation;
    }

    // If we got a different task, release it and return null
    if (reservation) {
      // Note: In a real implementation, we'd need to handle releasing the lease
      // For now, we'll just return null
      console.warn(`Got unexpected task ${reservation.task.id} when trying to reserve ${taskId}`);
    }

    return null;
  }

  private getTaskDependents(taskId: string): string[] {
    try {
      const dependents = DAGSchema.getDependents(this.db, taskId);
      return dependents.map(dep => dep.task_id);
    } catch (error) {
      console.error('Failed to get task dependents:', error);
      return [];
    }
  }

  private getTaskBlockers(taskId: string): string[] {
    try {
      const dependencies = DAGSchema.getTaskDependencies(this.db, taskId);
      return dependencies
        .filter(dep => !this.isTaskCompleted(dep.depends_on_task_id))
        .map(dep => dep.depends_on_task_id);
    } catch (error) {
      console.error('Failed to get task blockers:', error);
      return [];
    }
  }

  private getTaskDependencies(taskId: string): TaskDependency[] {
    try {
      const dependencies = DAGSchema.getTaskDependencies(this.db, taskId);
      return dependencies.map(dep => ({
        taskId: dep.task_id,
        dependsOn: dep.depends_on_task_id,
        dependencyType: dep.dependency_type,
        description: dep.description
      }));
    } catch (error) {
      console.error('Failed to get task dependencies:', error);
      return [];
    }
  }

  private isTaskCompleted(taskId: string): boolean {
    // This would need to check the actual task state
    // For now, assume no tasks are completed
    return false;
  }

  /**
   * Clean up old validation cache entries
   */
  cleanupValidationCache(olderThanMs: number = 24 * 60 * 60 * 1000): number {
    return DAGSchema.cleanValidationCache(this.db, olderThanMs);
  }

  /**
   * Get database schema validation status
   */
  validateDatabaseSchema(): { isValid: boolean; errors: string[] } {
    return DAGSchema.validateSchema(this.db);
  }
}