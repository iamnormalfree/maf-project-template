// ABOUTME: Core DAG dependency management for MAF constraint system
// ABOUTME: Provides dependency validation, topological sorting, and cycle detection

export interface TaskDependency {
  taskId: string;
  dependsOn: string;
  dependencyType: 'hard' | 'soft';
  description?: string;
}

export interface DAGTask {
  id: string;
  title?: string;
  description?: string;
  constraint?: string;
  priority: number;
  dependencies: TaskDependency[];
  metadata?: Record<string, any>;
}

export interface DAGValidationResult {
  isValid: boolean;
  cycles: string[][];
  missingDependencies: string[];
  orphanedTasks: string[];
  sortedTasks: DAGTask[];
  errors: string[];
}

export interface DependencyGraph {
  nodes: Map<string, DAGTask>;
  edges: Map<string, Set<string>>;
  inDegree: Map<string, number>;
}

/**
 * Core DAG dependency manager with validation and topological sorting
 */
export class DAGDependencyManager {
  private graph: DependencyGraph;
  private validationCache: Map<string, DAGValidationResult>;

  constructor() {
    this.graph = {
      nodes: new Map(),
      edges: new Map(),
      inDegree: new Map()
    };
    this.validationCache = new Map();
  }

  /**
   * Add a task to the dependency graph
   */
  addTask(task: DAGTask): void {
    this.graph.nodes.set(task.id, task);

    // Initialize edges and in-degree if not exists
    if (!this.graph.edges.has(task.id)) {
      this.graph.edges.set(task.id, new Set());
    }
    if (!this.graph.inDegree.has(task.id)) {
      this.graph.inDegree.set(task.id, 0);
    }

    // Add dependencies (allow missing ones for validation purposes)
    for (const dep of task.dependencies) {
      try {
        this.addDependency(dep.taskId, dep.dependsOn, dep.dependencyType);
      } catch (error) {
        // If dependency target doesn't exist, create a placeholder and add the dependency
        // This allows validation to detect missing dependencies
        if (!this.graph.nodes.has(dep.dependsOn)) {
          this.graph.edges.set(dep.dependsOn, new Set());
          this.graph.inDegree.set(dep.dependsOn, 0);
        }
        const currentInDegree = this.graph.inDegree.get(dep.taskId) || 0;
        this.graph.inDegree.set(dep.taskId, currentInDegree + 1);
        this.graph.edges.get(dep.taskId)!.add(dep.dependsOn);
      }
    }

    // Invalidate cache
    this.validationCache.clear();
  }

  /**
   * Remove a task from the dependency graph
   */
  removeTask(taskId: string): boolean {
    const task = this.graph.nodes.get(taskId);
    if (!task) {
      return false;
    }

    // Remove all dependencies for this task
    for (const dep of task.dependencies) {
      this.removeDependency(dep.taskId, dep.dependsOn);
    }

    // Remove task from graph
    this.graph.nodes.delete(taskId);
    this.graph.edges.delete(taskId);
    this.graph.inDegree.delete(taskId);

    // Invalidate cache
    this.validationCache.clear();
    return true;
  }

  /**
   * Add a dependency between two tasks
   */
  addDependency(taskId: string, dependsOn: string, type: 'hard' | 'soft' = 'hard'): void {
    if (!this.graph.nodes.has(taskId) || !this.graph.nodes.has(dependsOn)) {
      throw new Error(`Cannot add dependency: missing task(s) ${taskId} -> ${dependsOn}`);
    }

    // Add edge
    if (!this.graph.edges.has(taskId)) {
      this.graph.edges.set(taskId, new Set());
    }
    this.graph.edges.get(taskId)!.add(dependsOn);

    // Update in-degree
    const currentInDegree = this.graph.inDegree.get(taskId) || 0;
    this.graph.inDegree.set(taskId, currentInDegree + 1);

    // Update task dependencies
    const task = this.graph.nodes.get(taskId)!;
    const existingDep = task.dependencies.find(d => d.dependsOn === dependsOn);
    if (!existingDep) {
      task.dependencies.push({
        taskId,
        dependsOn,
        dependencyType: type
      });
    }

    // Invalidate cache
    this.validationCache.clear();
  }

  /**
   * Remove a dependency between two tasks
   */
  removeDependency(taskId: string, dependsOn: string): boolean {
    const edges = this.graph.edges.get(taskId);
    if (!edges || !edges.has(dependsOn)) {
      return false;
    }

    // Remove edge
    edges.delete(dependsOn);

    // Update in-degree
    const currentInDegree = this.graph.inDegree.get(taskId) || 0;
    this.graph.inDegree.set(taskId, Math.max(0, currentInDegree - 1));

    // Update task dependencies
    const task = this.graph.nodes.get(taskId);
    if (task) {
      task.dependencies = task.dependencies.filter(d => d.dependsOn !== dependsOn);
    }

    // Invalidate cache
    this.validationCache.clear();
    return true;
  }

  /**
   * Validate the dependency graph for cycles and other issues
   */
  validateGraph(): DAGValidationResult {
    const cacheKey = `validate_${this.graph.nodes.size}_${this.graph.edges.size}`;
    const cached = this.validationCache.get(cacheKey);
    if (cached) {
      return cached;
    }

    const result: DAGValidationResult = {
      isValid: true,
      cycles: [],
      missingDependencies: [],
      orphanedTasks: [],
      sortedTasks: [],
      errors: []
    };

    // Check for missing dependencies
    for (const [taskId, task] of this.graph.nodes) {
      for (const dep of task.dependencies) {
        if (!this.graph.nodes.has(dep.dependsOn)) {
          result.missingDependencies.push(`${taskId} depends on missing task ${dep.dependsOn}`);
          result.isValid = false;
        }
      }
    }

    // Detect cycles using Kahn's algorithm
    const cycles = this.detectCycles();
    result.cycles = cycles;
    if (cycles.length > 0) {
      result.isValid = false;
      result.errors.push(`Found ${cycles.length} cycle(s) in dependency graph`);
    }

    // Find orphaned tasks (no dependencies and no dependents)
    const orphanedTasks = this.findOrphanedTasks();
    result.orphanedTasks = orphanedTasks;

    // Get topological sort if graph is valid
    if (result.isValid) {
      try {
        result.sortedTasks = this.topologicalSort();
      } catch (error) {
        result.isValid = false;
        result.errors.push(`Topological sort failed: ${error}`);
      }
    }

    this.validationCache.set(cacheKey, result);
    return result;
  }

  /**
   * Get tasks that can be executed (no unmet dependencies)
   */
  getExecutableTasks(): DAGTask[] {
    const validation = this.validateGraph();
    if (!validation.isValid) {
      return [];
    }

    const executableTasks: DAGTask[] = [];
    const completedTasks = new Set<string>(); // This would come from task state

    for (const task of validation.sortedTasks) {
      const canExecute = task.dependencies.every(dep => {
        // For now, check if dependency exists and has no unmet dependencies
        const depTask = this.graph.nodes.get(dep.dependsOn);
        return depTask && completedTasks.has(dep.dependsOn);
      });

      if (canExecute) {
        executableTasks.push(task);
      }
    }

    return executableTasks;
  }

  /**
   * Get tasks in dependency order with constraint-based filtering
   */
  getTasksInDependencyOrder(constraint?: string): DAGTask[] {
    const validation = this.validateGraph();
    if (!validation.isValid) {
      throw new Error(`Cannot get tasks: dependency graph is invalid - ${validation.errors.join(', ')}`);
    }

    let tasks = validation.sortedTasks;

    // Filter by constraint if specified
    if (constraint) {
      tasks = tasks.filter(task => !task.constraint || task.constraint === constraint);
    }

    return tasks;
  }

  /**
   * Check if adding a dependency would create a cycle
   */
  wouldCreateCycle(taskId: string, dependsOn: string): boolean {
    if (taskId === dependsOn) {
      return true; // Self-dependency
    }

    // Check if dependsOn already has a path to taskId
    return this.hasPath(dependsOn, taskId);
  }

  /**
   * Check if there's a path from source to target in the current graph
   */
  hasPath(source: string, target: string): boolean {
    if (source === target) {
      return true;
    }

    const visited = new Set<string>();
    const stack = [source];

    while (stack.length > 0) {
      const current = stack.pop()!;
      if (current === target) {
        return true;
      }

      if (visited.has(current)) {
        continue;
      }
      visited.add(current);

      const dependencies = this.graph.edges.get(current) || new Set();
      for (const dependency of dependencies) {
        if (!visited.has(dependency)) {
          stack.push(dependency);
        }
      }
    }

    return false;
  }

  /**
   * Check if a task exists in the DAG manager
   */
  hasTask(taskId: string): boolean {
    return this.graph.nodes.has(taskId);
  }

  /**
   * Get dependency statistics for monitoring
   */
  getStatistics(): {
    totalTasks: number;
    totalDependencies: number;
    averageDependenciesPerTask: number;
    maxDependencyDepth: number;
    cyclicComponents: number;
  } {
    const totalTasks = this.graph.nodes.size;
    const totalDependencies = Array.from(this.graph.edges.values())
      .reduce((sum, edges) => sum + edges.size, 0);

    const averageDependenciesPerTask = totalTasks > 0 ? totalDependencies / totalTasks : 0;

    const maxDepth = this.calculateMaxDependencyDepth();
    const cyclicComponents = this.detectCycles().length;

    return {
      totalTasks,
      totalDependencies,
      averageDependenciesPerTask,
      maxDependencyDepth: maxDepth,
      cyclicComponents
    };
  }

  /**
   * Clear all tasks and dependencies
   */
  clear(): void {
    this.graph.nodes.clear();
    this.graph.edges.clear();
    this.graph.inDegree.clear();
    this.validationCache.clear();
  }

  // Private methods

  private detectCycles(): string[][] {
    return this.detectCyclesWithEdges(this.graph.edges);
  }

  private detectCyclesWithEdges(edges: Map<string, Set<string>>): string[][] {
    const cycles: string[][] = [];
    const visited = new Set<string>();
    const recursionStack = new Set<string>();
    const path: string[] = [];

    const dfs = (nodeId: string): boolean => {
      if (recursionStack.has(nodeId)) {
        // Found a cycle
        const cycleStart = path.indexOf(nodeId);
        if (cycleStart !== -1) {
          cycles.push([...path.slice(cycleStart), nodeId]);
        }
        return true;
      }

      if (visited.has(nodeId)) {
        return false;
      }

      visited.add(nodeId);
      recursionStack.add(nodeId);
      path.push(nodeId);

      const nodeEdges = edges.get(nodeId) || new Set();
      for (const neighbor of nodeEdges) {
        if (dfs(neighbor)) {
          return true;
        }
      }

      recursionStack.delete(nodeId);
      path.pop();
      return false;
    };

    for (const nodeId of this.graph.nodes.keys()) {
      if (!visited.has(nodeId)) {
        dfs(nodeId);
      }
    }

    return cycles;
  }

  private findOrphanedTasks(): string[] {
    const hasDependents = new Set<string>();

    // Mark all tasks that are depended upon
    for (const [taskId, edges] of this.graph.edges) {
      for (const dependent of edges) {
        hasDependents.add(dependent);
      }
    }

    // Find tasks with no dependencies and no dependents
    const orphaned: string[] = [];
    for (const [taskId, task] of this.graph.nodes) {
      if (task.dependencies.length === 0 && !hasDependents.has(taskId)) {
        orphaned.push(taskId);
      }
    }

    return orphaned;
  }

  private topologicalSort(): DAGTask[] {
    const result: DAGTask[] = [];
    const inDegree = new Map(this.graph.inDegree);
    const queue: string[] = [];

    // Find nodes with no dependencies and sort them for deterministic order
    const readyNodes: string[] = [];
    for (const [taskId, degree] of inDegree) {
      if (degree === 0) {
        readyNodes.push(taskId);
      }
    }

    // Sort by task priority, then by ID for deterministic ordering
    readyNodes.sort((a, b) => {
      const taskA = this.graph.nodes.get(a);
      const taskB = this.graph.nodes.get(b);
      if (taskA && taskB) {
        if (taskA.priority !== taskB.priority) {
          return taskA.priority - taskB.priority;
        }
      }
      return a.localeCompare(b);
    });

    queue.push(...readyNodes);

    while (queue.length > 0) {
      const current = queue.shift()!;
      const task = this.graph.nodes.get(current);
      if (task) {
        result.push(task);
      }

      // Process dependents and collect newly ready nodes
      const newlyReady: string[] = [];
      const dependents = this.getDependents(current);
      for (const dependent of dependents) {
        const currentDegree = inDegree.get(dependent) || 0;
        inDegree.set(dependent, currentDegree - 1);

        if (currentDegree - 1 === 0) {
          newlyReady.push(dependent);
        }
      }

      // Sort newly ready nodes and add to queue
      newlyReady.sort((a, b) => {
        const taskA = this.graph.nodes.get(a);
        const taskB = this.graph.nodes.get(b);
        if (taskA && taskB) {
          if (taskA.priority !== taskB.priority) {
            return taskA.priority - taskB.priority;
          }
        }
        return a.localeCompare(b);
      });

      queue.push(...newlyReady);
    }

    // Check if all nodes were processed (cycle detection)
    if (result.length !== this.graph.nodes.size) {
      throw new Error('Topological sort failed: graph contains cycles');
    }

    return result;
  }

  private getDependents(taskId: string): string[] {
    const dependents: string[] = [];
    for (const [potentialDependent, edges] of this.graph.edges) {
      if (edges.has(taskId)) {
        dependents.push(potentialDependent);
      }
    }
    return dependents;
  }

  private calculateMaxDependencyDepth(): number {
    let maxDepth = 0;

    const calculateDepth = (taskId: string, visited: Set<string>): number => {
      if (visited.has(taskId)) {
        return 0; // Cycle detected, stop recursion
      }

      visited.add(taskId);
      const dependencies = this.graph.edges.get(taskId) || new Set();

      if (dependencies.size === 0) {
        visited.delete(taskId);
        return 1;
      }

      let maxChildDepth = 0;
      for (const dep of dependencies) {
        maxChildDepth = Math.max(maxChildDepth, calculateDepth(dep, new Set(visited)));
      }

      visited.delete(taskId);
      return maxChildDepth + 1;
    };

    for (const taskId of this.graph.nodes.keys()) {
      maxDepth = Math.max(maxDepth, calculateDepth(taskId, new Set()));
    }

    return maxDepth;
  }
}